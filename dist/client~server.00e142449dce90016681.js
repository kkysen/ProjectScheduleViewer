(window["webpackJsonp"] = window["webpackJsonp"] || []).push([["client~server"],{

/***/ "./src/ts/ProjectScheduleViewer/share/data/Data.ts":
/*!*********************************************************!*\
  !*** ./src/ts/ProjectScheduleViewer/share/data/Data.ts ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst DataAccessor_1 = __webpack_require__(/*! ./access/DataAccessor */ \"./src/ts/ProjectScheduleViewer/share/data/access/DataAccessor.ts\");\nconst Employee_1 = __webpack_require__(/*! ./access/Employee */ \"./src/ts/ProjectScheduleViewer/share/data/access/Employee.ts\");\nconst Position_1 = __webpack_require__(/*! ./access/Position */ \"./src/ts/ProjectScheduleViewer/share/data/access/Position.ts\");\nconst Team_1 = __webpack_require__(/*! ./access/Team */ \"./src/ts/ProjectScheduleViewer/share/data/access/Team.ts\");\nconst dataAccessors = { positions: Position_1.positions, employees: Employee_1.employees, leaders: Employee_1.leaders, teams: Team_1.teams };\nexports.data = DataAccessor_1.DataAccessor.data(dataAccessors);\nexports.getAppData = function (sources) {\n    exports.data.refresh();\n    return exports.data.get(sources);\n};\n\n\n//# sourceURL=webpack:///./src/ts/ProjectScheduleViewer/share/data/Data.ts?");

/***/ }),

/***/ "./src/ts/ProjectScheduleViewer/share/data/access/DataAccessor.ts":
/*!************************************************************************!*\
  !*** ./src/ts/ProjectScheduleViewer/share/data/access/DataAccessor.ts ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst DataAccessor_1 = __webpack_require__(/*! ../../../../util/data/DataAccessor */ \"./src/ts/util/data/DataAccessor.ts\");\nexports.DataAccessor = DataAccessor_1.DataAccessorFactory.for();\n\n\n//# sourceURL=webpack:///./src/ts/ProjectScheduleViewer/share/data/access/DataAccessor.ts?");

/***/ }),

/***/ "./src/ts/ProjectScheduleViewer/share/data/access/Employee.ts":
/*!********************************************************************!*\
  !*** ./src/ts/ProjectScheduleViewer/share/data/access/Employee.ts ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst DataAccessor_1 = __webpack_require__(/*! ./DataAccessor */ \"./src/ts/ProjectScheduleViewer/share/data/access/DataAccessor.ts\");\nconst Position_1 = __webpack_require__(/*! ./Position */ \"./src/ts/ProjectScheduleViewer/share/data/access/Position.ts\");\nconst willBeLeader = (employee) => employee.isLeader;\nconst GENERIC_EMPLOYEE_LAST_NAME = \"???\";\nconst createGenericEmployee = function (position) {\n    return {\n        firstName: position.name,\n        lastName: GENERIC_EMPLOYEE_LAST_NAME,\n        level: position.level,\n        isLeader: false,\n        isReal: false,\n    };\n};\nconst createName = function ({ firstName, lastName }) {\n    return `${firstName} ${lastName}`;\n};\nexports.genericEmployeeName = function (position) {\n    return createName(createGenericEmployee(position));\n};\nexports.employees = DataAccessor_1.DataAccessor.new({\n    source: e => e.employees,\n    parse: ([firstName, lastName, level, isLeader]) => ({ firstName, lastName, level, isLeader: !!isLeader, isReal: true }),\n    preParsed: ({ positions }) => positions.all.map(createGenericEmployee),\n    create: (employee, id, { positions }) => {\n        const { firstName, lastName, level, isLeader, isReal } = employee;\n        const position = positions.by.level(level);\n        return !position ? undefined : {\n            id,\n            name: createName(employee),\n            firstName,\n            lastName,\n            position,\n            isLeader,\n            isReal,\n        };\n    },\n    by: { name: \"\" },\n}, { positions: Position_1.positions });\nexports.leaders = DataAccessor_1.DataAccessor.mapped(({ employees }) => employees.all\n    .filter(willBeLeader)\n    .map((e, i) => Object.assign(e, {\n    leaderId: i,\n    team: () => undefined,\n})), { name: \"\" }, { employees: exports.employees });\n\n\n//# sourceURL=webpack:///./src/ts/ProjectScheduleViewer/share/data/access/Employee.ts?");

/***/ }),

/***/ "./src/ts/ProjectScheduleViewer/share/data/access/Month.ts":
/*!*****************************************************************!*\
  !*** ./src/ts/ProjectScheduleViewer/share/data/access/Month.ts ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst monthArgs = [\n    \"January\",\n    \"February\",\n    \"March\",\n    \"April\",\n    \"May\",\n    \"June\",\n    \"July\",\n    \"August\",\n    \"September\",\n    \"October\",\n    \"November\",\n    \"December\",\n].map(name => ({ name }));\nexports.Months = monthArgs.map((month, i) => ({\n    ...month,\n    ordinal: i,\n    date: new Date(new Date(2000, 1, 1).setMonth(i)),\n}));\n\n\n//# sourceURL=webpack:///./src/ts/ProjectScheduleViewer/share/data/access/Month.ts?");

/***/ }),

/***/ "./src/ts/ProjectScheduleViewer/share/data/access/Position.ts":
/*!********************************************************************!*\
  !*** ./src/ts/ProjectScheduleViewer/share/data/access/Position.ts ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst utils_1 = __webpack_require__(/*! ../../../../util/functional/utils */ \"./src/ts/util/functional/utils.ts\");\nconst DataAccessor_1 = __webpack_require__(/*! ./DataAccessor */ \"./src/ts/ProjectScheduleViewer/share/data/access/DataAccessor.ts\");\nexports.positions = DataAccessor_1.DataAccessor.new({\n    source: e => e.positions,\n    parse: ([level, name, rate]) => ({ level, name, rate }),\n    create: utils_1.identity,\n    by: { level: 0 },\n}, {});\n\n\n//# sourceURL=webpack:///./src/ts/ProjectScheduleViewer/share/data/access/Position.ts?");

/***/ }),

/***/ "./src/ts/ProjectScheduleViewer/share/data/access/Team.ts":
/*!****************************************************************!*\
  !*** ./src/ts/ProjectScheduleViewer/share/data/access/Team.ts ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst DataAccessor_1 = __webpack_require__(/*! ./DataAccessor */ \"./src/ts/ProjectScheduleViewer/share/data/access/DataAccessor.ts\");\nconst Employee_1 = __webpack_require__(/*! ./Employee */ \"./src/ts/ProjectScheduleViewer/share/data/access/Employee.ts\");\nconst Month_1 = __webpack_require__(/*! ./Month */ \"./src/ts/ProjectScheduleViewer/share/data/access/Month.ts\");\nconst Position_1 = __webpack_require__(/*! ./Position */ \"./src/ts/ProjectScheduleViewer/share/data/access/Position.ts\");\nconst makeProject = function (employees, leader, team) {\n    const byId = employees.by.index;\n    return ({ id, name, percentLikelihood, employees: parsedEmployees }) => {\n        const employees = parsedEmployees.map(({ employee, months }) => ({\n            employee: {\n                employee: byId(employee),\n                project: () => project,\n            },\n            months: months.map(({ month, percentCommitted }) => ({ month: Month_1.Months[month], percentCommitted })),\n        })).filter(e => !!e.employee);\n        const project = {\n            id,\n            team,\n            leader,\n            name,\n            employees: employees.map(e => e.employee),\n            months: Month_1.Months.map((month, i) => ({\n                month,\n                employees: employees.map(({ employee, months }) => ({\n                    employee,\n                    percentCommitted: months[i].percentCommitted,\n                })),\n            })),\n            percentLikelihood,\n        };\n        return project;\n    };\n};\nconst makeTeam = function (employees, leader, { projects }) {\n    const team = {\n        id: leader.leaderId,\n        leader,\n        projects: projects.map(makeProject(employees, leader, () => team)),\n    };\n    leader.team = () => team;\n    return team;\n};\nexports.teams = DataAccessor_1.DataAccessor.new({\n    source: e => e.teams,\n    parse: projects => ({\n        projects: projects.map(([id, name, employees, percentLikelihood]) => ({\n            id,\n            name,\n            employees: employees.map(([employee, months]) => ({\n                employee,\n                months: months.map((percentCommitted, i) => ({ month: i, percentCommitted }))\n            })),\n            percentLikelihood,\n        })).sortBy(e => e.id),\n    }),\n    create: (parsed, id, { leaders, employees }) => makeTeam(employees, leaders.all[id], parsed),\n    by: {},\n}, { leaders: Employee_1.leaders, employees: Employee_1.employees, positions: Position_1.positions });\n\n\n//# sourceURL=webpack:///./src/ts/ProjectScheduleViewer/share/data/access/Team.ts?");

/***/ }),

/***/ "./src/ts/ProjectScheduleViewer/ssr/components/App.tsx":
/*!*************************************************************!*\
  !*** ./src/ts/ProjectScheduleViewer/ssr/components/App.tsx ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst React = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\nconst animate_1 = __webpack_require__(/*! ../../../util/animate */ \"./src/ts/util/animate.ts\");\nconst anyWindow_1 = __webpack_require__(/*! ../../../util/anyWindow */ \"./src/ts/util/anyWindow.ts\");\nconst utils_1 = __webpack_require__(/*! ../../../util/utils */ \"./src/ts/util/utils.ts\");\nconst Graph_1 = __webpack_require__(/*! ./Graph */ \"./src/ts/ProjectScheduleViewer/ssr/components/Graph.tsx\");\nconst ProjectTables_1 = __webpack_require__(/*! ./ProjectTables */ \"./src/ts/ProjectScheduleViewer/ssr/components/ProjectTables.tsx\");\nexports.appId = \"app\";\nexports.App = ({ data }) => {\n    anyWindow_1.globals({ data });\n    return React.createElement(\"div\", { id: exports.appId },\n        React.createElement(Graph_1.Graph, { data: data }),\n        React.createElement(ProjectTables_1.ProjectTables, { data: data }),\n        React.createElement(\"button\", { onClick: () => console.log(data) }, \"Button\"));\n};\nif (anyWindow_1.isBrowser) {\n    anyWindow_1.anyWindow.start = () => {\n        const bys = utils_1.moduloIndexer([\"index\", \"employee\", \"project\", \"team\", \"position\"]);\n        anyWindow_1.anyWindow.stop = animate_1.animate(i => anyWindow_1.anyWindow.by = bys(i));\n    };\n}\n\n\n//# sourceURL=webpack:///./src/ts/ProjectScheduleViewer/ssr/components/App.tsx?");

/***/ }),

/***/ "./src/ts/ProjectScheduleViewer/ssr/components/Graph.tsx":
/*!***************************************************************!*\
  !*** ./src/ts/ProjectScheduleViewer/ssr/components/Graph.tsx ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst d3_scale_1 = __webpack_require__(/*! d3-scale */ \"./node_modules/d3-scale/index.js\");\nconst d3_scale_chromatic_1 = __webpack_require__(/*! d3-scale-chromatic */ \"./node_modules/d3-scale-chromatic/index.js\");\nconst d3_time_format_1 = __webpack_require__(/*! d3-time-format */ \"./node_modules/d3-time-format/index.js\");\nconst React = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\nconst react_1 = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\nconst anyWindow_1 = __webpack_require__(/*! ../../../util/anyWindow */ \"./src/ts/util/anyWindow.ts\");\nconst HashMap_1 = __webpack_require__(/*! ../../../util/collections/HashMap */ \"./src/ts/util/collections/HashMap.ts\");\nconst VariableAreaStack_1 = __webpack_require__(/*! ../../../util/components/svg/graph/VariableAreaStack */ \"./src/ts/util/components/svg/graph/VariableAreaStack.tsx\");\nconst isType_1 = __webpack_require__(/*! ../../../util/types/isType */ \"./src/ts/util/types/isType.ts\");\nconst utils_1 = __webpack_require__(/*! ../../../util/utils */ \"./src/ts/util/utils.ts\");\nconst prepareData = function (data) {\n    const hash = (date) => +date;\n    const map = HashMap_1.HashMap.perfectHash({\n        keysHashEquals: {\n            hash,\n            equals: (t1, t2) => hash(t1) === hash(t2),\n        },\n    });\n    data.teams.all\n        .flatMap(e => e.projects._())\n        .flatMap(e => e.months._())\n        .forEach(({ month, employees }) => map.getOrPutDefault(month.date, []).addAll(employees._()));\n    return map;\n};\nclass Graph extends react_1.Component {\n    constructor(props) {\n        super(props);\n        this.baseColor = utils_1.moduloIndexer(d3_scale_chromatic_1.schemeCategory10);\n        this.byColor = (e, i) => this.baseColor(this.state.by(e, i));\n        this.by = {\n            Amar: e => e.employee.firstName === \"Amar\" ? 1 : 0,\n            index: (e, i) => i,\n            employee: e => e.employee.id,\n            project: e => e.project().id,\n            team: e => e.project().team().id,\n            position: e => e.employee.position.level,\n        };\n        this.state = {\n            by: this.by.index,\n            color: this.byColor,\n        };\n        const _ = this;\n        anyWindow_1.globalProperties({\n            set onlyColor(only) {\n                const onlySet = new Set(isType_1.isArray(only) ? only : [only]);\n                _.setState({\n                    color: (employee, i) => !onlySet.has(i) ? \"white\" : _.baseColor(i),\n                });\n            },\n            set by(by) {\n                _.setState({ by: _.by[by] });\n            },\n        });\n    }\n    render() {\n        const { data } = this.props;\n        const { color, by } = this.state;\n        return React.createElement(React.Fragment, null, VariableAreaStack_1.VariableAreaStack({\n            data: prepareData(data),\n            values: {\n                x: d => d,\n                y: d => d.percentCommitted * d.employee.project().percentLikelihood,\n                z: d => d.employee,\n            },\n            orderBy: by,\n            flat: true,\n            color,\n            scale: {\n                x: d3_scale_1.scaleTime(),\n            },\n            axes: {\n                x: (axis, xData) => axis\n                    .tickFormat(d3_time_format_1.timeFormat(\"%B\"))\n                    .ticks(xData.length),\n            },\n            axesNames: {\n                x: \"Month\",\n                y: \"Number of Employees\",\n            },\n            size: { width: 1000, height: 500 },\n            margins: { left: 50, top: 50, right: 50, bottom: 50 },\n        }));\n    }\n}\nexports.Graph = Graph;\n\n\n//# sourceURL=webpack:///./src/ts/ProjectScheduleViewer/ssr/components/Graph.tsx?");

/***/ }),

/***/ "./src/ts/ProjectScheduleViewer/ssr/components/ProjectTables.tsx":
/*!***********************************************************************!*\
  !*** ./src/ts/ProjectScheduleViewer/ssr/components/ProjectTables.tsx ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst React = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\nconst react_1 = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\nconst ProjectTable = ({ project }) => {\n    const border = { border: \"1px solid black\" };\n    return React.createElement(React.Fragment, null,\n        React.createElement(\"br\", null),\n        \"% Likelihood: \",\n        project.percentLikelihood,\n        React.createElement(\"br\", null),\n        React.createElement(\"table\", { style: { ...border, borderCollapse: \"collapse\" } },\n            React.createElement(\"thead\", null,\n                React.createElement(\"tr\", null,\n                    React.createElement(\"th\", { style: border },\n                        \"Project: \",\n                        project.name),\n                    project.employees.map((e, i) => React.createElement(\"th\", { key: i, style: border }, e.employee.name)))),\n            React.createElement(\"tbody\", null, project.months.map((month, i) => React.createElement(\"tr\", { key: i },\n                React.createElement(\"td\", { style: border }, month.month.name),\n                month.employees.map((employee, i) => {\n                    return React.createElement(\"td\", { key: i, style: border }, employee.percentCommitted);\n                }))))),\n        React.createElement(\"br\", null));\n};\nexports.ProjectTables = ({ data }) => React.createElement(\"div\", null, data.teams.all.map(team => React.createElement(react_1.Fragment, { key: team.id },\n    React.createElement(\"br\", null),\n    React.createElement(\"br\", null),\n    \"Team \",\n    team.leader.name,\n    React.createElement(\"br\", null),\n    React.createElement(\"br\", null),\n    team.projects.map(project => React.createElement(ProjectTable, { project: project, key: project.id })),\n    React.createElement(\"br\", null),\n    React.createElement(\"br\", null))));\n\n\n//# sourceURL=webpack:///./src/ts/ProjectScheduleViewer/ssr/components/ProjectTables.tsx?");

/***/ }),

/***/ "./src/ts/util/All.ts":
/*!****************************!*\
  !*** ./src/ts/util/All.ts ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.All = {\n    of(a, bySample) {\n        const map = (key) => new Map(a.map(e => [e[key], e]));\n        const mapBy = (key) => {\n            const byMap = map(key);\n            return (by) => byMap.get(by);\n        };\n        const maps = Object.keys(bySample)\n            .map(key => [key, mapBy(key)]);\n        const byMap = maps.toObject();\n        return {\n            all: a,\n            by: Object.assign(byMap, {\n                index: (i) => a[i],\n            }),\n        };\n    },\n};\n\n\n//# sourceURL=webpack:///./src/ts/util/All.ts?");

/***/ }),

/***/ "./src/ts/util/DebugProxy.ts":
/*!***********************************!*\
  !*** ./src/ts/util/DebugProxy.ts ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst isType_1 = __webpack_require__(/*! ./types/isType */ \"./src/ts/util/types/isType.ts\");\nexports.DebugProxy = {\n    for(target, options = {}, name = \"Target\") {\n        const handler = {\n            get: (target, p, receiver) => {\n                if (!target.hasProperty(p) && (!isType_1.isString(p) || !p.startsWith(\"__\"))) {\n                    throw new TypeError(`${p.toString()} is not yet implemented on ${name} ${target}`);\n                }\n                return Reflect.get(target, p, receiver);\n            },\n        };\n        for (const [key, value] of Object.entries(options)) {\n            if (value === false) {\n                handler[key] = undefined;\n            }\n        }\n        return new Proxy(target, handler);\n    },\n};\n\n\n//# sourceURL=webpack:///./src/ts/util/DebugProxy.ts?");

/***/ }),

/***/ "./src/ts/util/Range.ts":
/*!******************************!*\
  !*** ./src/ts/util/Range.ts ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst anyWindow_1 = __webpack_require__(/*! ./anyWindow */ \"./src/ts/util/anyWindow.ts\");\nexports.Range = {\n    new(from, to) {\n        const _from = to === undefined ? 0 : from;\n        const _to = to === undefined ? from : to;\n        return {\n            toArray() {\n                return [...new Array(_to - _from)].map((e, i) => i + _from);\n            },\n            map(map) {\n                return this.toArray().map(map);\n            },\n            filter(func) {\n                return this.toArray().filter(func);\n            },\n            forEach(func) {\n                for (let i = _from; i < _to; i++) {\n                    func(i);\n                }\n            },\n            toInterval() {\n                return [_from, _to];\n            },\n        };\n    },\n    ofDomain(domain) {\n        return this.new(Math.min(...domain), Math.max(...domain));\n    },\n};\nanyWindow_1.globals({ range: exports.Range });\n\n\n//# sourceURL=webpack:///./src/ts/util/Range.ts?");

/***/ }),

/***/ "./src/ts/util/animate.ts":
/*!********************************!*\
  !*** ./src/ts/util/animate.ts ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.animationFrame = function () {\n    return new Promise(resolve => requestAnimationFrame(() => resolve()));\n};\nexports.animate = function (animator) {\n    let stop = false;\n    (async () => {\n        for (let i = 0; !stop; i++) {\n            await exports.animationFrame();\n            animator(i);\n        }\n    })();\n    return () => {\n        stop = true;\n    };\n};\n\n\n//# sourceURL=webpack:///./src/ts/util/animate.ts?");

/***/ }),

/***/ "./src/ts/util/anyWindow.ts":
/*!**********************************!*\
  !*** ./src/ts/util/anyWindow.ts ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(global) {\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.isBrowser = typeof window !== \"undefined\";\nexports.anyWindow = exports.isBrowser ? window : global;\nexports.globals = function (o) {\n    Object.assign(exports.anyWindow, o);\n};\nexports.globalProperties = function (o) {\n    Object.assignProperties(exports.anyWindow, o);\n};\nexports.globals({ globals: exports.globals, globalProperties: exports.globalProperties });\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../node_modules/webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack:///./src/ts/util/anyWindow.ts?");

/***/ }),

/***/ "./src/ts/util/cache.ts":
/*!******************************!*\
  !*** ./src/ts/util/cache.ts ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getter = function (t) {\n    return () => t;\n};\nexports.makeGetter = function () {\n    return exports.getter;\n};\nexports.cache = function (getter) {\n    let cache;\n    return ((...args) => cache !== undefined ? cache : (cache = getter(...args)));\n};\nexports.refreshableCache = function (getter) {\n    let cache;\n    return {\n        get: ((...args) => cache !== undefined ? cache : (cache = getter(...args))),\n        refresh: () => cache = undefined,\n    };\n};\n\n\n//# sourceURL=webpack:///./src/ts/util/cache.ts?");

/***/ }),

/***/ "./src/ts/util/collections/ArrayStack.ts":
/*!***********************************************!*\
  !*** ./src/ts/util/collections/ArrayStack.ts ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst bind_1 = __webpack_require__(/*! ../decorators/bind */ \"./src/ts/util/decorators/bind.ts\");\nconst Collection_1 = __webpack_require__(/*! ./Collection */ \"./src/ts/util/collections/Collection.ts\");\nconst HashEquals_1 = __webpack_require__(/*! ./HashEquals */ \"./src/ts/util/collections/HashEquals.ts\");\nexports.ArrayStack = {\n    new({ elements = [], hashEquals = HashEquals_1.HashEquals.default() }) {\n        const { equals } = hashEquals;\n        const a = bind_1.bind([...elements]);\n        const { size, push, pop, last: peek, clear, remove } = a;\n        // noinspection TypeScriptValidateJSTypes\n        return Collection_1.Collection.basedOn({\n            size,\n            add: e => (push(e), true),\n            remove: Collection_1.checkSizeChanged(size, (e) => remove(e, equals)),\n            clear,\n            [Symbol.iterator]: () => a[Symbol.iterator](),\n            push,\n            peek,\n            pop,\n        }, hashEquals, exports.ArrayStack.new);\n    },\n};\n\n\n//# sourceURL=webpack:///./src/ts/util/collections/ArrayStack.ts?");

/***/ }),

/***/ "./src/ts/util/collections/Collection.ts":
/*!***********************************************!*\
  !*** ./src/ts/util/collections/Collection.ts ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst HashEquals_1 = __webpack_require__(/*! ./HashEquals */ \"./src/ts/util/collections/HashEquals.ts\");\nexports.checkSizeChanged = function (size, wrapped) {\n    return arg => {\n        const originalSize = size();\n        wrapped(arg);\n        return originalSize !== size();\n    };\n};\nexports.Collection = {\n    basedOn(base, hashEquals, constructor) {\n        const { size, add, remove, clear } = base;\n        const { hash, equals } = HashEquals_1.HashEquals.fastEquals(hashEquals);\n        const makeHas = function (iter) {\n            return e => [...iter].some(HashEquals_1.Equals.bind(equals, e));\n        };\n        const iterArray = function (method) {\n            return (iter) => method([...iter]);\n        };\n        const iterArrayForEach = function (func) {\n            return iterArray(a => a.forEach(func));\n        };\n        const _checkSizeChanged = function (wrapped) {\n            return exports.checkSizeChanged(size, wrapped);\n        };\n        const construct = () => constructor;\n        const asyncConstruct = () => async ({ hashEquals, elements }) => construct()({ hashEquals, elements: await elements });\n        const maybeAsyncConstruct = ((async) => async ? asyncConstruct() : construct());\n        const arrayMethod = function (getter, returner) {\n            return (f, args) => {\n                const a = _.toArray();\n                const m = getter(a).bind(a);\n                // Object spread is used here like this\n                // so that all properties of args are included,\n                // even if they are not in CollectionArgs.\n                // This is b/c CollectionArgs can be subtyped,\n                // but Collection won't know about it and can't know about it,\n                // b/c Collection can't have higher kinded generic types.\n                return returner({\n                    ...{\n                        hashEquals: HashEquals_1.HashEquals.default(),\n                    },\n                    ...args || {},\n                    ...{\n                        elements: m(f),\n                    },\n                });\n            };\n        };\n        const forEachMethod = function (forEachGetter) {\n            return arrayMethod(forEachGetter, (args) => args.elements);\n        };\n        const mappingMethod = function (mapGetter, async) {\n            return arrayMethod(mapGetter, maybeAsyncConstruct(async));\n        };\n        const filteringMethod = function (filterGetter, async) {\n            return (filter) => arrayMethod(filterGetter, maybeAsyncConstruct(async))(filter, { hashEquals });\n        };\n        const extended = {\n            isEmpty: () => size() === 0,\n            has: makeHas(base),\n            hasAll: iterArray(a => a.every(_.has)),\n            addAll: iterArrayForEach(add),\n            removeAll: _checkSizeChanged(iterArrayForEach(remove)),\n            retainAll: _checkSizeChanged(iter => _.retainIf(makeHas(iter))),\n            removeIf: _checkSizeChanged(filter => _.toArray().filter(filter).forEach(remove)),\n            retainIf: filter => _.removeIf(filter.negate()),\n            replaceAll: replacer => {\n                const mapped = _.toArray().map(replacer);\n                clear();\n                _.addAll(mapped);\n            },\n            toString: () => `[${_.toArray().join(\", \")}]`,\n            toArray: () => [..._],\n            random: () => _.toArray().random(),\n            forEach: forEachMethod(a => a.forEach),\n            asyncForEach: forEachMethod(a => a.asyncForEach),\n            equals: (c) => size() === c.size() && (() => {\n                const a = c.toArray();\n                return _.toArray().every((e, i) => equals(e, a[i]));\n            })(),\n            hash: () => _.toArray().map(hash).map(HashEquals_1.Hash.makeNumber).reduce((hash, h) => 31 * (hash | 0) + h, 1),\n            filter: filteringMethod(a => a.filter, false),\n            map: mappingMethod(a => a.map, false),\n            mapFilter: mappingMethod(a => a.mapFilter, false),\n            asyncFilter: filteringMethod(a => a.asyncFilter, true),\n            asyncMap: mappingMethod(a => a.asyncMap, true),\n            asyncMapFilter: mappingMethod(a => a.asyncMapFilter, true),\n            clone: () => _.map(e => e),\n        };\n        // type system not good enough with difference types, need to assert\n        const _ = Object.assign(base, extended);\n        return _;\n    },\n};\n\n\n//# sourceURL=webpack:///./src/ts/util/collections/Collection.ts?");

/***/ }),

/***/ "./src/ts/util/collections/HashEquals.ts":
/*!***********************************************!*\
  !*** ./src/ts/util/collections/HashEquals.ts ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst cache_1 = __webpack_require__(/*! ../cache */ \"./src/ts/util/cache.ts\");\nconst utils_1 = __webpack_require__(/*! ../functional/utils */ \"./src/ts/util/functional/utils.ts\");\nconst fnv1a_1 = __webpack_require__(/*! ../hash/fnv1a */ \"./src/ts/util/hash/fnv1a.ts\");\nconst regex_1 = __webpack_require__(/*! ../regex */ \"./src/ts/util/regex.ts\");\nconst isType_1 = __webpack_require__(/*! ../types/isType */ \"./src/ts/util/types/isType.ts\");\nconst isReferentialEqualitySource = (() => {\n    const twoArgs = /\\(([^\\s,]*)\\s*,\\s*([^\\s)]*)\\)/;\n    const equality = /\\s*\\1\\s*===\\s*\\2/;\n    const functionBody = regex_1.regex.join(/\\s*{\\s*return/, equality, /\\s*;\\s*}/);\n    const func = regex_1.regex.join(/function\\s*/, twoArgs, functionBody);\n    const arrow = /\\s*=>/;\n    const arrowFuncWithBody = regex_1.regex.join(twoArgs, arrow, functionBody);\n    const arrowFunc = regex_1.regex.join(twoArgs, arrow, equality);\n    return s => [arrowFunc, arrowFuncWithBody, func].some(regex => regex.test(s));\n})();\nexports.Equals = {\n    bind: (equals, t) => {\n        return _t => equals(t, _t);\n    },\n    default: cache_1.getter((t1, t2) => exports.Equals.referential()(t1, t2) || exports.Hash.default()(t1) === exports.Hash.default()(t2)),\n    referential: () => Object.is,\n    fastEquals: (equals) => {\n        // means equals is using referential equality, don't repeat\n        // double checking referential equality is cheap except for strings\n        const referential = exports.Equals.referential();\n        if (equals === referential || isReferentialEqualitySource(equals.toString())) {\n            return referential;\n        }\n        return (t1, t2) => t1 === t2 || equals(t1, t2);\n    },\n};\nexports.Hash = {\n    makeNumber(hash) {\n        return isType_1.isNumber(hash) ? hash : fnv1a_1.fnv1a(isType_1.isString(hash) ? hash : exports.Hash.default()(hash));\n    },\n    // TODO maybe fix type assertion\n    default: () => JSON.stringify,\n    referential: () => utils_1.identity,\n};\nconst defaultHashEquals = {\n    hash: exports.Hash.referential(),\n    equals: exports.Equals.referential(),\n};\n// can't properly type generic constant\n// (only functions can be generic, but won't return same value each time)\nconst referentialHashEquals = {\n    hash: exports.Hash.referential(),\n    equals: exports.Equals.referential(),\n};\nexports.HashEquals = {\n    default: () => defaultHashEquals,\n    referential: () => referentialHashEquals,\n    isReferential: hashEquals => hashEquals === referentialHashEquals,\n    fastEquals: ({ hash, equals }) => ({ hash, equals: exports.Equals.fastEquals(equals) }),\n};\n\n\n//# sourceURL=webpack:///./src/ts/util/collections/HashEquals.ts?");

/***/ }),

/***/ "./src/ts/util/collections/HashMap.ts":
/*!********************************************!*\
  !*** ./src/ts/util/collections/HashMap.ts ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst bind_1 = __webpack_require__(/*! ../decorators/bind */ \"./src/ts/util/decorators/bind.ts\");\nconst iterables_1 = __webpack_require__(/*! ../iterables */ \"./src/ts/util/iterables.ts\");\nconst typeAliases_1 = __webpack_require__(/*! ../types/typeAliases */ \"./src/ts/util/types/typeAliases.ts\");\nconst utils_1 = __webpack_require__(/*! ../utils */ \"./src/ts/util/utils.ts\");\nconst ArrayStack_1 = __webpack_require__(/*! ./ArrayStack */ \"./src/ts/util/collections/ArrayStack.ts\");\nconst Collection_1 = __webpack_require__(/*! ./Collection */ \"./src/ts/util/collections/Collection.ts\");\nconst HashEquals_1 = __webpack_require__(/*! ./HashEquals */ \"./src/ts/util/collections/HashEquals.ts\");\nconst HashSet_1 = __webpack_require__(/*! ./HashSet */ \"./src/ts/util/collections/HashSet.ts\");\n// TODO add referential version like in HashSet\n// TODO add perfect hash version (for keys like Date or enums), b/c can be optimized (no linked lists)\n// TODO add perfect hash version to HashSet, too\nexports.HashMap = {\n    new({ elements = [], hashEquals, keysHashEquals = HashEquals_1.HashEquals.default(), valuesHashEquals = HashEquals_1.HashEquals.default(), }) {\n        const exists = (node) => node.exists;\n        const { hash, equals } = HashEquals_1.HashEquals.fastEquals(keysHashEquals);\n        const { hash: valueHash, equals: valueEquals } = HashEquals_1.HashEquals.fastEquals(valuesHashEquals);\n        hashEquals = {\n            hash: ({ key, value }) => HashEquals_1.Hash.makeNumber(hash(key)) ^ HashEquals_1.Hash.makeNumber(valueHash(value)),\n            equals: (e1, e2) => equals(e1.key, e2.key) && valueEquals(e1.value, e2.value),\n        };\n        const table = bind_1.bind(new typeAliases_1.NativeMap());\n        const { clear, values } = table;\n        const getNode = function (key) {\n            const h = hash(key);\n            let node = table.get(h);\n            if (!node) {\n                return {\n                    exists: false,\n                    key,\n                    put: value => (table.set(h, { key, value }), undefined),\n                    remove: () => undefined,\n                };\n            }\n            // explicitly check first node\n            if (equals(key, node.key)) {\n                const n = node;\n                n.key = key;\n                return {\n                    exists: true,\n                    key,\n                    value: n.value,\n                    put: value => {\n                        const v = n.value;\n                        n.value = value;\n                        return v;\n                    },\n                    remove: () => {\n                        const value = n.value;\n                        table.delete(h);\n                        return value;\n                    },\n                };\n            }\n            for (let next, prev; next = node.next; prev = node, node = next) {\n                const k = node.key;\n                if (!equals(k, key)) {\n                    continue;\n                }\n                const n = node;\n                n.key = key;\n                return {\n                    exists: true,\n                    key: n.key,\n                    value: n.value,\n                    put: value => {\n                        const v = n.value;\n                        n.value = value;\n                        return v;\n                    },\n                    remove: () => {\n                        const value = n.value;\n                        if (prev) {\n                            prev.next = next;\n                        }\n                        else if (next) {\n                            table.set(h, next);\n                        }\n                        else {\n                            table.delete(h);\n                        }\n                        return value;\n                    },\n                };\n            }\n            const n = node;\n            return {\n                exists: false,\n                key,\n                put: value => (n.next = { key, value }, undefined),\n                remove: () => n.next = undefined,\n            };\n        };\n        const size = () => table.size;\n        const put = function (key, value) {\n            return getNode(key).put(value);\n        };\n        const removeKey = function (key) {\n            return getNode(key).remove();\n        };\n        const sized = function (wrapped) {\n            return Collection_1.checkSizeChanged(size, wrapped);\n        };\n        const base = {\n            size,\n            clear,\n            add: ({ key, value }) => {\n                const node = getNode(key);\n                node.put(value);\n                return !node.exists;\n            },\n            remove: ({ key, value }) => {\n                const node = getNode(key);\n                if (exists(node) && valueEquals(value, node.value)) {\n                    node.remove();\n                    return true;\n                }\n                return false;\n            },\n            [Symbol.iterator]: function* () {\n                for (let node of values()) {\n                    for (let n = node; n; n = n.next) {\n                        yield n;\n                    }\n                }\n            },\n        };\n        const hasKey = function (key) {\n            return getNode(key).exists;\n        };\n        const get = function (key) {\n            return getNode(key).value;\n        };\n        const getOrDefault = function (key, defaultValue) {\n            const node = getNode(key);\n            return exists(node) ? node.value : defaultValue;\n        };\n        const getOrPutDefault = function (key, defaultValue) {\n            const node = getNode(key);\n            return exists(node) ? node.value : (node.put(defaultValue), defaultValue);\n        };\n        const getByValue = function (remove) {\n            return function (v) {\n                for (const { key, value } of base) {\n                    if (valueEquals(v, value)) {\n                        if (remove) {\n                            removeKey(key);\n                        }\n                        return true;\n                    }\n                }\n                return false;\n            };\n        };\n        const removeValue = getByValue(true);\n        const putIfDefined = function (node, value) {\n            if (value !== undefined) {\n                node.put(value);\n            }\n            else {\n                node.remove();\n            }\n            return value;\n        };\n        // noinspection TypeScriptValidateJSTypes\n        const map = {\n            ...{},\n            put,\n            removeKey,\n            removeValue,\n            hasKey,\n            get,\n            getOrDefault,\n            getOrPutDefault,\n            putIfAbsent: (key, value) => {\n                const node = getNode(key);\n                if (!node.exists) {\n                    node.put(value);\n                }\n            },\n            putAll: map => {\n                // TODO optimize\n                addAll(map);\n            },\n            replace: (key, value) => {\n                const node = getNode(key);\n                return exists(node) ? node.put(value) : undefined;\n            },\n            replaceIfEquals: (key, oldValue, newValue) => {\n                const node = getNode(key);\n                const replace = exists(node) && valueEquals(oldValue, node.value);\n                if (replace) {\n                    node.put(newValue);\n                }\n                return replace;\n            },\n            computeIfAbsent: ((key, mapper) => {\n                const node = getNode(key);\n                if (exists(node)) {\n                    return node.value;\n                }\n                return putIfDefined(node, mapper(key));\n            }),\n            computeIfPresent: (key, remapper) => {\n                const node = getNode(key);\n                if (!exists(node)) {\n                    return undefined;\n                }\n                return putIfDefined(node, remapper(key, node.value));\n            },\n            compute: (key, remapper) => {\n                const node = getNode(key);\n                return putIfDefined(node, remapper(key, node.value));\n            },\n            merge: (key, value, remapper) => {\n                const node = getNode(key);\n                return putIfDefined(node, remapper(key, exists(node) ? node.value : value));\n            },\n            hasValue: getByValue(false),\n            entries: () => _,\n            keys: () => Collection_1.Collection.basedOn({\n                size,\n                clear,\n                add: () => {\n                    throw new utils_1.NotImplementedError();\n                },\n                remove: e => {\n                    const node = getNode(e);\n                    node.remove();\n                    return node.exists;\n                },\n                ...iterables_1.iterables.map(_, e => e.key),\n                has: hasKey,\n            }, keysHashEquals, HashSet_1.HashSet.new),\n            values: () => Collection_1.Collection.basedOn({\n                size,\n                clear,\n                add: () => {\n                    throw new utils_1.NotImplementedError();\n                },\n                remove: removeValue,\n                ...iterables_1.iterables.map(_, e => e.value),\n            }, valuesHashEquals, ArrayStack_1.ArrayStack.new),\n        };\n        const extended = {\n            has: ({ key, value }) => {\n                const node = getNode(key);\n                return exists(node) && valueEquals(value, node.value);\n            },\n            toString: () => `{${toArray()\n                .map(({ key, value }) => `${key} = ${value}`)\n                .join(\"\\n\")}`,\n        };\n        const _ = Collection_1.Collection.basedOn({\n            ...base,\n            ...map,\n            ...extended,\n        }, hashEquals, exports.HashMap.new);\n        // TODO why do I need this type assertion\n        const { toArray, addAll } = _;\n        addAll(elements);\n        return _;\n    },\n    referential(args) {\n        args.keysHashEquals = HashEquals_1.HashEquals.referential();\n        return exports.HashMap.new(args);\n    },\n    perfectHash(args) {\n        // TODO\n        return exports.HashMap.new(args);\n    },\n};\n\n\n//# sourceURL=webpack:///./src/ts/util/collections/HashMap.ts?");

/***/ }),

/***/ "./src/ts/util/collections/HashSet.ts":
/*!********************************************!*\
  !*** ./src/ts/util/collections/HashSet.ts ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst bind_1 = __webpack_require__(/*! ../decorators/bind */ \"./src/ts/util/decorators/bind.ts\");\nconst iterables_1 = __webpack_require__(/*! ../iterables */ \"./src/ts/util/iterables.ts\");\nconst typeAliases_1 = __webpack_require__(/*! ../types/typeAliases */ \"./src/ts/util/types/typeAliases.ts\");\nconst Collection_1 = __webpack_require__(/*! ./Collection */ \"./src/ts/util/collections/Collection.ts\");\nconst HashEquals_1 = __webpack_require__(/*! ./HashEquals */ \"./src/ts/util/collections/HashEquals.ts\");\nconst HashMap_1 = __webpack_require__(/*! ./HashMap */ \"./src/ts/util/collections/HashMap.ts\");\nexports.HashSet = {\n    new({ elements = [], hashEquals = HashEquals_1.HashEquals.default() }) {\n        if (HashEquals_1.HashEquals.isReferential(hashEquals)) {\n            // if using referential HashEquals, use optimized referential version\n            return exports.HashSet.referential({ elements });\n        }\n        const { value, done } = elements[Symbol.iterator]().next();\n        if (!done && ![\"object\", \"function\"].includes(typeof value)) {\n            // if using a primitive type, always use referential version\n            return exports.HashSet.referential({ elements }); // don't need hashEquals\n        }\n        const { size, clear, hasKey: has, put, removeKey: remove, keys, replaceAll, } = HashMap_1.HashMap.new({\n            elements: iterables_1.iterables.map(elements, e => ({ key: e, value: null })),\n            keysHashEquals: hashEquals,\n            valuesHashEquals: {\n                hash: t => 0,\n                equals: () => true,\n            },\n        });\n        // noinspection TypeScriptValidateJSTypes\n        return Collection_1.Collection.basedOn({\n            size,\n            add: e => put(e, null) !== null,\n            remove: e => remove(e) === null,\n            clear,\n            [Symbol.iterator]: () => keys()[Symbol.iterator](),\n            has,\n            replaceAll: replacer => replaceAll(({ key, value }) => ({ key: replacer(key), value })),\n        }, hashEquals, exports.HashSet.new);\n    },\n    referential(args) {\n        const { elements = [] } = args;\n        // always use referential HashEquals, ignore args\n        const hashEquals = HashEquals_1.HashEquals.referential();\n        const nativeSet = bind_1.bind(new typeAliases_1.NativeSet(elements));\n        const { add, has, delete: remove, clear, [Symbol.iterator]: iterator, forEach } = nativeSet;\n        const size = () => nativeSet.size;\n        // noinspection TypeScriptValidateJSTypes\n        return Collection_1.Collection.basedOn({\n            size,\n            add: Collection_1.checkSizeChanged(size, add),\n            remove,\n            clear,\n            [Symbol.iterator]: () => iterator(),\n            has,\n            forEach: (func => {\n                let i = 0;\n                forEach(e => func(e, i++));\n            }),\n        }, hashEquals, exports.HashSet.referential);\n    },\n};\n\n\n//# sourceURL=webpack:///./src/ts/util/collections/HashSet.ts?");

/***/ }),

/***/ "./src/ts/util/components/svg/graph/Axes.tsx":
/*!***************************************************!*\
  !*** ./src/ts/util/components/svg/graph/Axes.tsx ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst d3_selection_1 = __webpack_require__(/*! d3-selection */ \"./node_modules/d3-selection/index.js\");\nconst React = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\nconst FauxComponent_1 = __webpack_require__(/*! ../../../dom/faux/FauxComponent */ \"./src/ts/util/dom/faux/FauxComponent.ts\");\nconst react_1 = __webpack_require__(/*! ../../../react */ \"./src/ts/util/react.tsx\");\nconst utils_1 = __webpack_require__(/*! ../utils */ \"./src/ts/util/components/svg/utils.ts\");\nconst utils_2 = __webpack_require__(/*! ../utils */ \"./src/ts/util/components/svg/utils.ts\");\nexports.Axes = function ({ axes, names, size: { width, height }, margins: { left, top, right, bottom }, }) {\n    const [gx, gy] = Object.values(axes).map(axis => {\n        const { element: g, render } = FauxComponent_1.FauxComponent.new(\"g\");\n        axis(d3_selection_1.select(g));\n        return render();\n    });\n    // TODO check magic number 20 in names.x translate\n    return react_1.renderNodesObj({\n        axes: React.createElement(React.Fragment, null,\n            React.createElement(\"g\", { transform: utils_1.translate(0, height) }, gx),\n            gy),\n        names: React.createElement(React.Fragment, null,\n            names.x && React.createElement(\"text\", { transform: utils_1.translate(width / 2, height + top), style: { textAnchor: \"middle\" } }, names.x),\n            names.y && React.createElement(\"text\", { transform: utils_2.rotate(-90), y: -left, x: -height / 2, dy: \"1em\", style: { textAnchor: \"middle\" } }, names.y)),\n    });\n};\n\n\n//# sourceURL=webpack:///./src/ts/util/components/svg/graph/Axes.tsx?");

/***/ }),

/***/ "./src/ts/util/components/svg/graph/VariableAreaStack.tsx":
/*!****************************************************************!*\
  !*** ./src/ts/util/components/svg/graph/VariableAreaStack.tsx ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst classNames = __webpack_require__(/*! classnames */ \"./node_modules/classnames/index.js\");\nconst d3_array_1 = __webpack_require__(/*! d3-array */ \"./node_modules/d3-array/index.js\");\nconst d3_axis_1 = __webpack_require__(/*! d3-axis */ \"./node_modules/d3-axis/index.js\");\nconst d3_scale_1 = __webpack_require__(/*! d3-scale */ \"./node_modules/d3-scale/index.js\");\nconst d3_scale_chromatic_1 = __webpack_require__(/*! d3-scale-chromatic */ \"./node_modules/d3-scale-chromatic/index.js\");\nconst d3_shape_1 = __webpack_require__(/*! d3-shape */ \"./node_modules/d3-shape/index.js\");\nconst React = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\nconst utils_1 = __webpack_require__(/*! ../../../functional/utils */ \"./src/ts/util/functional/utils.ts\");\nconst production_1 = __webpack_require__(/*! ../../../production */ \"./src/ts/util/production.ts\");\nconst Range_1 = __webpack_require__(/*! ../../../Range */ \"./src/ts/util/Range.ts\");\nconst isType_1 = __webpack_require__(/*! ../../../types/isType */ \"./src/ts/util/types/isType.ts\");\nconst utils_2 = __webpack_require__(/*! ../../../utils */ \"./src/ts/util/utils.ts\");\nconst utils_3 = __webpack_require__(/*! ../utils */ \"./src/ts/util/components/svg/utils.ts\");\nconst Axes_1 = __webpack_require__(/*! ./Axes */ \"./src/ts/util/components/svg/graph/Axes.tsx\");\nexports.VariableAreaStack = function ({ data: nonStandardizedData, values, flat = false, orderBy, offset = d3_shape_1.stackOffsetNone, color = d3_scale_chromatic_1.schemeCategory10, scale: { x: xScale = d3_scale_1.scaleLinear(), y: yScale = d3_scale_1.scaleLinear(), } = {}, axes: { x: xAxis = utils_1.identity, y: yAxis = utils_1.identity, } = {}, axesNames = {}, size, margins = {}, className, curve, defined, glyph, reverse = false, }) {\n    const dataAsEntries = function (data) {\n        const a = [...data];\n        if (a.length === 0) {\n            return [];\n        }\n        if (!isType_1.isArray(a[0])) {\n            return a;\n        }\n        return a.map(([key, value]) => ({ key, value }));\n    };\n    /**\n     * Adds a new entry before every non-first entry\n     * w/ the current key and the previous value.\n     * This creates a column chart effect.\n     */\n    const flattenData = function (data) {\n        if (!flat) {\n            return data;\n        }\n        return data.flatMap((e, i, a) => {\n            if (i === 0) {\n                return e;\n            }\n            return [\n                {\n                    key: e.key,\n                    value: a[i - 1].value,\n                },\n                e,\n            ];\n        });\n    };\n    const standardizeData = function () {\n        const data = dataAsEntries(nonStandardizedData);\n        switch (data.length) {\n            case 0:\n                return;\n            case 1:\n                return data;\n            default:\n                return flattenData(data);\n        }\n    };\n    const data = standardizeData();\n    if (!data) {\n        return;\n    }\n    const { width, height } = size;\n    const { left = 0, top = 0, bottom = 0, right = 0 } = margins;\n    const _margins = { left, top, bottom, right };\n    const outerWidth = width + left + right;\n    const outerHeight = height + top + bottom;\n    const xData = data.map(e => e.key);\n    const xValues = xData.map(values.x);\n    const yData = data.map(e => e.value);\n    const numZ = Math.max(...yData.map(e => e.length));\n    const zRange = Range_1.Range.new(numZ);\n    const keys = zRange.toArray();\n    const zData = zRange\n        // TODO check mapFilter or map\n        .map(i => yData._().mapFilter(e => e[i]))\n        .mapFilter(e => {\n        if (e.length === 0) {\n            return;\n        }\n        if (production_1.development) {\n            if (new Set(e.map(values.z)).size > 1) {\n                throw new Error(`each zDatum contains non-unique keys`);\n            }\n        }\n        return {\n            key: values.z(e[0]),\n            value: e.map(values.y),\n        };\n    });\n    const colorFromArray = function (colors) {\n        const color = utils_2.moduloIndexer(colors);\n        return (z, i) => color(i);\n    };\n    const x = xScale.range([0, width])\n        .domain(d3_array_1.extent(xValues));\n    const y = yScale.range([height, 0]);\n    const _color = isType_1.isReadonlyArray(color) ? colorFromArray(color) : color;\n    const path = d3_shape_1.area()\n        .x((d, i) => x(xValues[i]))\n        .y0(d => y(d[0]))\n        .y1(d => y(d[1]));\n    curve && path.curve(curve);\n    defined && path.defined((d, i) => defined(d.data, i));\n    const seriesData = d3_shape_1.stack()\n        .keys(keys)\n        .value((d, i) => {\n        if (i > d.length) {\n            return 0;\n        }\n        return values.y(d[i]);\n    })\n        .order(!orderBy ? d3_shape_1.stackOrderNone : series => series.map((e, i) => ({ i, value: zData[i].key }))\n        .sortBy(e => orderBy(e.value, e.i))\n        .map(e => e.i))\n        .offset(offset)(yData._());\n    y.domain(d3_array_1.extent(seriesData.flatten(2)));\n    reverse && seriesData.reverse();\n    const paths = seriesData.mapFilter(path);\n    return React.createElement(\"svg\", { width: outerWidth, height: outerHeight },\n        React.createElement(\"g\", { transform: utils_3.translate(left, top) },\n            React.createElement(\"g\", null, paths.map((path, i) => React.createElement(\"path\", { key: i, className: classNames(\"vx-area-stack\", className), d: path, fill: _color(zData[i].key, i), onMouseEnter: () => console.log(zData[i].key, zData[i].value) }))),\n            !!glyph && React.createElement(\"g\", { className: \"vx-area-stack-glyphs\" }, xData.map(glyph)),\n            React.createElement(\"g\", null, Axes_1.Axes({\n                axes: {\n                    x: xAxis(d3_axis_1.axisBottom(x), xData),\n                    y: yAxis(d3_axis_1.axisLeft(y), yData),\n                },\n                names: axesNames,\n                size,\n                margins: _margins,\n            }))));\n};\n\n\n//# sourceURL=webpack:///./src/ts/util/components/svg/graph/VariableAreaStack.tsx?");

/***/ }),

/***/ "./src/ts/util/components/svg/utils.ts":
/*!*********************************************!*\
  !*** ./src/ts/util/components/svg/utils.ts ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.translate = (x, y) => `translate(${x},${y})`;\nexports.rotate = (degrees) => `rotate(${degrees})`;\n\n\n//# sourceURL=webpack:///./src/ts/util/components/svg/utils.ts?");

/***/ }),

/***/ "./src/ts/util/data/DataAccessor.ts":
/*!******************************************!*\
  !*** ./src/ts/util/data/DataAccessor.ts ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst All_1 = __webpack_require__(/*! ../All */ \"./src/ts/util/All.ts\");\nconst cache_1 = __webpack_require__(/*! ../cache */ \"./src/ts/util/cache.ts\");\nconst objectFields_1 = __webpack_require__(/*! ../objectFields */ \"./src/ts/util/objectFields.ts\");\nexports.DataAccessorFactory = {\n    for() {\n        return {\n            new: ({ source, parse, preParsed = () => [], create, by }, argsGetter) => {\n                return cache_1.cache(async (sources) => {\n                    const args = await objectFields_1.objectFields.awaitFunctions(argsGetter, sources);\n                    const raw = await source(sources)(args);\n                    const parsed = raw.map(parse);\n                    // do it twice so index is correct 2nd time\n                    const a = [\n                        ...parsed.filter((e, i) => create(e, i, args)),\n                        ...preParsed(args),\n                    ].mapFilter((e, i) => create(e, i, args));\n                    return {\n                        ...All_1.All.of(a, by),\n                        parsed,\n                        raw,\n                    };\n                });\n            },\n            mapped: (create, by, argsGetter) => {\n                return cache_1.cache(async (source) => {\n                    return All_1.All.of(create(await objectFields_1.objectFields.awaitFunctions(argsGetter, source)), by);\n                });\n            },\n            data: (dataAccessors) => {\n                return cache_1.refreshableCache((source) => {\n                    const dataPromises = objectFields_1.objectFields.callEachArgs(dataAccessors, source);\n                    return objectFields_1.objectFields.awaitAll(dataPromises);\n                });\n            },\n        };\n    },\n};\n\n\n//# sourceURL=webpack:///./src/ts/util/data/DataAccessor.ts?");

/***/ }),

/***/ "./src/ts/util/decorators/bind.ts":
/*!****************************************!*\
  !*** ./src/ts/util/decorators/bind.ts ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst anyWindow_1 = __webpack_require__(/*! ../anyWindow */ \"./src/ts/util/anyWindow.ts\");\nconst allExtensions_1 = __webpack_require__(/*! ../extensions/allExtensions */ \"./src/ts/util/extensions/allExtensions.ts\");\nallExtensions_1.addExtensions();\nexports.bind = function (target) {\n    if (typeof target !== \"object\") {\n        throw new Error(`cannot bind non-object: ${target}`);\n    }\n    const _target = target;\n    const isBindable = (value) => value.bind && !value.bound; // don't double bind methods\n    const bind = (f) => {\n        f = f.bind(_target);\n        f.bound = true;\n        return f;\n    };\n    const properties = Object.getAllPropertyNames(target)\n        .map(key => ({ key, value: _target[key] }))\n        .filter(({ value }) => isBindable(value))\n        .map(({ key, value }) => [key, bind(value)])\n        .toObject(true);\n    Object.defineImmutableProperties(target, properties);\n    return target;\n};\nanyWindow_1.globals({ bind: exports.bind });\nexports.bindClass = function (Target) {\n    return class extends Target {\n        // noinspection JSUnusedGlobalSymbols\n        constructor(...args) {\n            super(...args);\n            exports.bind(this);\n        }\n    };\n};\n\n\n//# sourceURL=webpack:///./src/ts/util/decorators/bind.ts?");

/***/ }),

/***/ "./src/ts/util/dom/faux/FauxComponent.ts":
/*!***********************************************!*\
  !*** ./src/ts/util/dom/faux/FauxComponent.ts ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst Range_1 = __webpack_require__(/*! ../../Range */ \"./src/ts/util/Range.ts\");\nconst FauxElement_1 = __webpack_require__(/*! ./FauxElement */ \"./src/ts/util/dom/faux/FauxElement.ts\");\nexports.FauxComponent = {\n    new(tagName) {\n        // const element = createElement(tagName);\n        // return {\n        //     element,\n        //     render: () => {\n        //         return Range.new(1000)\n        //             .map(() => element.toReact())\n        //             .random();\n        //         // return element.toReact();\n        //     }\n        // };\n        const element = FauxElement_1.FauxElement.new(tagName);\n        return {\n            element,\n            render: () => {\n                return Range_1.Range.new(1)\n                    .map(() => element.render())\n                    .random();\n            },\n        };\n    },\n};\n\n\n//# sourceURL=webpack:///./src/ts/util/dom/faux/FauxComponent.ts?");

/***/ }),

/***/ "./src/ts/util/dom/faux/FauxElement.ts":
/*!*********************************************!*\
  !*** ./src/ts/util/dom/faux/FauxElement.ts ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst react_1 = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\nconst cache_1 = __webpack_require__(/*! ../../cache */ \"./src/ts/util/cache.ts\");\nconst DebugProxy_1 = __webpack_require__(/*! ../../DebugProxy */ \"./src/ts/util/DebugProxy.ts\");\nconst production_1 = __webpack_require__(/*! ../../production */ \"./src/ts/util/production.ts\");\nconst utils_1 = __webpack_require__(/*! ../../utils */ \"./src/ts/util/utils.ts\");\nconst libQuerySelectorAll = __webpack_require__(/*! query-selector */ \"./node_modules/query-selector/index.js\");\nexports.FauxElement = (() => {\n    const skipNameTransformationExpressions = [\n        /^data-/,\n        /^aria-/,\n    ];\n    const attributeNameMap = new Map([\n        [\"class\", \"className\"],\n    ]);\n    const attributeToPropName = (name) => {\n        if (skipNameTransformationExpressions.some(e => e.test(name))) {\n            return name;\n        }\n        return attributeNameMap.get(name) || utils_1.camelCase(name);\n    };\n    const eventNameMap = new Map([]);\n    const eventToPropName = (type) => {\n        return eventNameMap.get(type) || type;\n    };\n    const itemIndexed = (a) => {\n        const _a = a;\n        _a.item = i => a[i];\n        return _a;\n    };\n    const arrayToNodeList = (nodes) => {\n        return itemIndexed(nodes);\n    };\n    const arrayToHTMLCollection = (elements) => {\n        const htmlCollection = itemIndexed(elements);\n        if (production_1.development) {\n            return DebugProxy_1.DebugProxy.for(htmlCollection, {}, \"FauxElement.HTMLCollection\");\n        }\n        return htmlCollection;\n    };\n    const arrayToDomTokenList = (tokens) => {\n        // TODO\n        return tokens;\n    };\n    const child = (node) => node;\n    const isFaux = (node) => !!node.render;\n    return {\n        new(tagName, namespaceURI = \"http://www.w3.org/1999/xhtml\") {\n            const ownerDocument = fauxDocument;\n            const nodeName = tagName;\n            const nodeType = 1;\n            let parentNode;\n            let parentElement;\n            const setParent = (parent) => {\n                parentElement = parentNode = parent;\n            };\n            let innerHTML = \"\";\n            const childNodes = arrayToNodeList([]);\n            const classList = arrayToDomTokenList([]);\n            const props = {};\n            const eventListeners = new Map();\n            const getAttribute = (name) => {\n                return props[attributeToPropName(name)] || null;\n                // return props.get(attributeToPropName(name)) || null;\n            };\n            const setAttribute = (name, value) => {\n                props[attributeToPropName(name)] = value;\n                // props.set(attributeToPropName(name), value);\n            };\n            const removeAttribute = (name) => {\n                delete props[attributeToPropName(name)];\n                // props.delete(attributeToPropName(name));\n            };\n            const getAttributeNode = (name) => {\n                const value = getAttribute(name);\n                if (!value) {\n                    return null;\n                }\n                const _attr = {\n                    name,\n                    value,\n                    specified: true,\n                    ownerElement: _,\n                };\n                const attr = _attr;\n                if (production_1.development) {\n                    return DebugProxy_1.DebugProxy.for(attr, {}, \"FauxElement.Attr\");\n                }\n                return attr;\n            };\n            const addEventListener = (type, listener, options) => {\n                const prop = eventToPropName(type);\n                const emptyListeners = [];\n                const listeners = eventListeners.get(prop) || (eventListeners.set(prop, emptyListeners), emptyListeners);\n                listeners.push(listener);\n            };\n            const removeEventListener = (type, listener, options) => {\n                const prop = eventToPropName(type);\n                const listeners = eventListeners.get(prop);\n                if (listeners) {\n                    listeners.remove(listener);\n                }\n            };\n            const appendChild = (newChild) => {\n                newChild.parentElement = _;\n                childNodes.push(child(newChild));\n                return newChild;\n            };\n            const removeChild = (oldChild) => {\n                const removed = childNodes.remove(child(oldChild));\n                if (!removed) {\n                    throw new Error(\"Not Found Error\");\n                }\n                return oldChild;\n            };\n            const remove = () => {\n                if (parentNode) {\n                    parentNode.removeChild(_);\n                }\n            };\n            const insertBefore = (newChild, refChild) => {\n                if (!refChild) {\n                    return appendChild(newChild);\n                }\n                const i = childNodes.indexOf(child(refChild));\n                if (i === -1) {\n                    return appendChild(child(newChild));\n                }\n                childNodes.add(i, child(newChild));\n                return newChild;\n            };\n            const isElement = (node) => e.nodeType === undefined || e.nodeType === 1;\n            const getChildren = () => {\n                return arrayToHTMLCollection(childNodes.filter(isElement));\n            };\n            const getSibling = (offset) => {\n                if (!parentNode) {\n                    return null;\n                }\n                const siblings = parentNode.childNodes;\n                return siblings[siblings.indexOf(_) + offset];\n            };\n            const querySelectorAll = (selectors) => {\n                return libQuerySelectorAll(selectors, _);\n            };\n            const querySelector = (selectors) => {\n                return querySelectorAll(selectors)[0] || null;\n            };\n            const getElementsByTagName = (tagName) => {\n                const children = getChildren();\n                if (children.length === 0) {\n                    return arrayToNodeList([]);\n                }\n                const shallowMatches = tagName === \"*\"\n                    ? children\n                    : children.filter(e => e.nodeName === tagName);\n                const allMatches = shallowMatches.flatMap(e => [...e.getElementsByTagName(tagName)]);\n                return arrayToNodeList(allMatches);\n            };\n            const getElementsByClassName = (className) => {\n                const children = getChildren();\n                if (children.length === 0) {\n                    return arrayToNodeList([]);\n                }\n                const shallowMatches = tagName === \"*\"\n                    ? children\n                    : children.filter(e => e.className === className || [...e.classList].includes(className));\n                const allMatches = shallowMatches.flatMap(e => [...e.getElementsByTagName(tagName)]);\n                return arrayToNodeList(allMatches);\n            };\n            const render = (key = 0) => {\n                // TODO\n                const children = getChildren().map(e => isFaux(e) ? e.render() : e);\n                if (innerHTML) {\n                    children.push(innerHTML);\n                }\n                // const i = anyWindow.i++;\n                // if (i % 1000 === 0 || true) {\n                //     console.log(\"rendering\", nodeName.padEnd(10), i);\n                // }\n                // console.log(props.size);\n                // const _props = Range.new(1000).map(() => ({key, ...[...props].toObject(true)})).random();\n                // const _props = Range.new(1000).map(() => ({key, ...props}));\n                props.key = key.toString();\n                return react_1.createElement(nodeName, props, children.length === 1 ? innerHTML : children);\n            };\n            const e = {\n                ownerDocument,\n                namespaceURI,\n                nodeName,\n                nodeType,\n                get parentNode() {\n                    return parentNode;\n                },\n                get parentElement() {\n                    return parentElement;\n                },\n                set parentNode(node) {\n                    setParent(node);\n                },\n                set parentElement(element) {\n                    setParent(element);\n                },\n                get innerHTML() {\n                    return innerHTML;\n                },\n                set innerHTML(html) {\n                    innerHTML = html;\n                },\n                get textContent() {\n                    return innerHTML;\n                },\n                set textContent(text) {\n                    innerHTML = text;\n                },\n                childNodes,\n                get children() {\n                    return getChildren();\n                },\n                get nextSibling() {\n                    return getSibling(+1);\n                },\n                get previousSibling() {\n                    return getSibling(-1);\n                },\n                classList,\n                get className() {\n                    return classList.join(\" \");\n                },\n                getAttribute,\n                setAttribute,\n                removeAttribute,\n                getAttributeNode,\n                addEventListener,\n                removeEventListener,\n                appendChild,\n                removeChild,\n                remove,\n                insertBefore,\n                querySelectorAll,\n                querySelector,\n                getElementsByTagName,\n                getElementsByClassName,\n                render,\n            };\n            const _ = e;\n            if (production_1.development) {\n                return DebugProxy_1.DebugProxy.for(_, {}, \"FauxElement\");\n            }\n            return _;\n        },\n    };\n})();\nconst fauxDocument = (() => {\n    const getDocumentElement = cache_1.cache(() => exports.FauxElement.new(\"html\"));\n    const document = {\n        createElement: (tagName) => exports.FauxElement.new(tagName),\n        createElementNS: exports.FauxElement.new,\n        get documentElement() {\n            return getDocumentElement();\n        },\n    };\n    const _ = document;\n    if (production_1.development) {\n        return DebugProxy_1.DebugProxy.for(_, {}, \"FauxDocument\");\n    }\n    return _;\n})();\n\n\n//# sourceURL=webpack:///./src/ts/util/dom/faux/FauxElement.ts?");

/***/ }),

/***/ "./src/ts/util/extensions/allExtensions.ts":
/*!*************************************************!*\
  !*** ./src/ts/util/extensions/allExtensions.ts ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst HashEquals_1 = __webpack_require__(/*! ../collections/HashEquals */ \"./src/ts/util/collections/HashEquals.ts\");\nconst Truthy_1 = __webpack_require__(/*! ../types/Truthy */ \"./src/ts/util/types/Truthy.ts\");\nconst immutableDescriptor = Object.freeze({\n    writable: false,\n    enumerable: false,\n    configurable: true,\n});\nconst defineSharedProperties = function (obj, sharedDescriptor, propertyValues, overwrite = true) {\n    const properties = Object.getOwnPropertyDescriptors(propertyValues);\n    Object.entries(properties).forEach(([propertyName, property]) => {\n        if (!overwrite && obj[propertyName]) {\n            return;\n        }\n        property = { ...property, ...sharedDescriptor };\n        if (property.get || property.set) {\n            delete property.writable;\n        }\n        properties[propertyName] = property;\n    });\n    Object.defineProperties(obj, properties);\n};\ndefineSharedProperties(Object, immutableDescriptor, {\n    defineSharedProperties,\n    defineImmutableProperties(obj, propertyValues, overwrite = true) {\n        defineSharedProperties(obj, immutableDescriptor, propertyValues, overwrite);\n    },\n});\nObject.defineImmutableProperties(Object, {\n    allKeys(t) {\n        return [...Object.getOwnPropertyNames(t), ...Object.getOwnPropertySymbols(t)];\n    },\n    allValues(t) {\n        return Object.allKeys(t).map(key => t[key]);\n    },\n    allEntries(t) {\n        return Object.allKeys(t).map(key => [key, t[key]]);\n    },\n    definePolyfillProperties(obj, propertyValues) {\n        Object.defineImmutableProperties(obj, propertyValues, false);\n    },\n    getPrototypeChain(object) {\n        const chain = [];\n        for (let o = object; o !== null; o = Object.getPrototypeOf(o)) {\n            chain.push(o);\n        }\n        return chain;\n    },\n    getAllPropertyNames(object) {\n        return Array.from(new Set(Object.getPrototypeChain(object)\n            .flatMap(proto => Object.getOwnPropertyNames(proto))));\n    },\n    assignProperties(target, ...sources) {\n        for (const source of sources) {\n            Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n        }\n    },\n    getting(key) {\n        return o => o[key];\n    },\n    deleting(key) {\n        return o => {\n            delete o[key];\n            return o;\n        };\n    },\n});\nObject.defineImmutableProperties(Object.prototype, {\n    hasProperty(property) {\n        for (let o = this; o !== null; o = Object.getPrototypeOf(o)) {\n            if (o.hasOwnProperty(property)) {\n                return true;\n            }\n        }\n        return false;\n    },\n    freeze() {\n        return Object.freeze(this);\n    },\n    seal() {\n        return Object.seal(this);\n    },\n    _clone() {\n        return Object.assign(Object.create(null), this);\n    },\n    fullClone() {\n        return Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));\n    },\n    mapFields(mapper) {\n        const obj = {};\n        for (const [key, value] of Object.entries(this)) {\n            obj[key] = mapper(value);\n        }\n        return obj;\n    },\n    freezeFields() {\n        for (const value of Object.values(this)) {\n            value.freeze();\n        }\n        return this;\n    }\n});\nObject.defineImmutableProperties(Function, {\n    compose(...funcs) {\n        const numFuncs = funcs.length;\n        if (numFuncs === 0) {\n            return () => undefined;\n        }\n        const [firstFunc, ...restFunc] = funcs;\n        if (numFuncs === 1) {\n            return firstFunc();\n        }\n        return function (...args) {\n            let result = firstFunc();\n            for (const func of funcs) {\n                result = func(result);\n            }\n            return result;\n        };\n    },\n});\nObject.defineImmutableProperties(Function.prototype, {\n    thenCall(nextFunc) {\n        return (arg) => nextFunc(this(arg));\n    },\n    applyReturning() {\n        return (arg) => {\n            this(arg);\n            return arg;\n        };\n    },\n    mapping() {\n        return array => array.map(this);\n    },\n    applying() {\n        return array => this(...array);\n    },\n    timed() {\n        const timer = (...args) => {\n            const { name } = this;\n            console.time(name);\n            const returnValue = this(...args);\n            console.timeEnd(name);\n            return returnValue;\n        };\n        return timer.named(\"timing_\" + this.name);\n    },\n    setName(name) {\n        Object.defineProperties(this, {\n            name: {\n                value: name,\n            },\n        });\n    },\n    named(name) {\n        this.setName(name);\n        return this;\n    },\n    negate() {\n        return ((...args) => !this(...args));\n    },\n});\nObject.defineImmutableProperties(Array.prototype, {\n    size() {\n        return this.length;\n    },\n    last() {\n        return this[this.length - 1];\n    },\n    clear() {\n        this.length = 0;\n    },\n    removeAt(index) {\n        return this.splice(index, 1)[0];\n    },\n    remove(value, equals) {\n        const i = !equals ? this.indexOf(value) : this.findIndex(HashEquals_1.Equals.bind(equals, value));\n        if (i !== -1) {\n            return this.removeAt(i);\n        }\n    },\n    add(index, value) {\n        this.splice(index, 0, value);\n    },\n    addAll(values, index = this.length) {\n        if (index === this.length) {\n            this.push(...values);\n        }\n        else {\n            this.splice(index, 0, ...values);\n        }\n    },\n    applyOn(func) {\n        return func(this);\n    },\n    callOn(func) {\n        return func(...this);\n    },\n    toObject(noPrototype = false) {\n        let o = noPrototype ? Object.create(null) : {};\n        for (const [k, v] of this) {\n            o[k] = v;\n        }\n        return o;\n    },\n    sortBy(key) {\n        this.sort((a, b) => key(a) - key(b));\n        return this;\n    },\n    random() {\n        return this[Math.floor(Math.random() * this.length)];\n    },\n    mapCall() {\n        return this.map(f => f());\n    },\n    callEach(u) {\n        this.forEach(f => f(u));\n    },\n    async asyncForEach(func) {\n        await Promise.all(this.map(func));\n    },\n    mapFilter(map) {\n        return this.map(map).filter(Truthy_1.truthy);\n    },\n    asyncMap(map) {\n        return Promise.all(this.map(map));\n    },\n    async asyncFilter(filter) {\n        return (await Promise.all(this.map(async (value, index, array) => ({ value, filtered: await filter(value, index, array) })))).filter(e => e.filtered).map(e => e.value);\n    },\n    async asyncMapFilter(map) {\n        return (await Promise.all(this.map(map))).filter(Truthy_1.truthy);\n    },\n    readOnly() {\n        return this;\n    },\n    _() {\n        return this;\n    },\n});\nObject.definePolyfillProperties(Array.prototype, {\n    flatMap(flatMap, thisArg) {\n        if (thisArg) {\n            flatMap = flatMap.bind(thisArg);\n        }\n        return [].concat(...this.map(flatMap));\n    },\n    flatten(depth = -1) {\n        // TODO faster flatten polyfill\n        return depth === 0\n            ? this\n            : this.reduce((a, e) => a.concat(Array.isArray(e) ? e.flatten(depth - 1) : e), []);\n    },\n});\nconst nativeSlice = String.prototype.slice;\nObject.defineImmutableProperties(String.prototype, {\n    equals(s) {\n        return this === s;\n    },\n    boundEquals() {\n        return s => this === s;\n    },\n    // allow negative indices for end\n    slice(start = 0, end = this.length) {\n        if (end < 0) {\n            end = this.length + end;\n        }\n        return nativeSlice.call(this, start, end);\n    },\n});\nObject.defineImmutableProperties(Number, {\n    isNumber(n) {\n        return !Number.isNaN(n);\n    },\n    toPixels(n) {\n        return Math.round(n) + \"px\";\n    },\n});\nObject.defineImmutableProperties(Map.prototype, {\n    map(map) {\n        return new Map([...this].map(([k, v]) => [k, map(v, k)]));\n    },\n});\nObject.defineImmutableProperties(Set.prototype, {\n    map(map) {\n        return new Set([...this].map(map));\n    },\n});\n// don't touch RegExp.prototype,\n// since modifying it will bail out of RegExp's fast paths.\nif (typeof window !== \"undefined\") {\n    Object.defineImmutableProperties(Node.prototype, {\n        appendBefore(node) {\n            const { parentNode } = this;\n            parentNode && parentNode.insertBefore(node, this);\n            return node;\n        },\n        appendAfter(node) {\n            const { nextSibling } = this;\n            nextSibling && nextSibling.appendBefore(node);\n            return node;\n        },\n    });\n    Object.defineImmutableProperties(Element.prototype, {\n        clearHTML() {\n            this.innerHTML = \"\";\n        },\n        setAttributes(attributes) {\n            for (const [attribute, value] of Object.entries(attributes)) {\n                if (value) {\n                    this.setAttribute(attribute, value.toString());\n                }\n            }\n        },\n    });\n    Object.defineImmutableProperties(HTMLElement.prototype, {\n        appendTo(parent) {\n            parent.appendChild(this);\n            return this;\n        },\n        appendNewElement(tagName) {\n            return this.appendChild(document.createElement(tagName));\n        },\n        appendDiv() {\n            return this.appendNewElement(\"div\");\n        },\n        appendButton(buttonText) {\n            const button = this.appendNewElement(\"button\");\n            button.innerText = buttonText;\n            return button;\n        },\n        appendBr() {\n            return this.appendNewElement(\"br\");\n        },\n        withInnerText(text) {\n            this.innerText = text;\n            return this;\n        },\n        withInnerHTML(html) {\n            this.innerHTML = html;\n            return this;\n        },\n    });\n    Object.defineImmutableProperties(HTMLIFrameElement.prototype, {\n        activate() {\n            this.appendTo(document.body);\n            return this;\n        },\n    });\n}\nexports.addExtensions = function () {\n};\n\n\n//# sourceURL=webpack:///./src/ts/util/extensions/allExtensions.ts?");

/***/ }),

/***/ "./src/ts/util/functional/utils.ts":
/*!*****************************************!*\
  !*** ./src/ts/util/functional/utils.ts ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.identity = (t) => t;\n\n\n//# sourceURL=webpack:///./src/ts/util/functional/utils.ts?");

/***/ }),

/***/ "./src/ts/util/hash/fnv1a.ts":
/*!***********************************!*\
  !*** ./src/ts/util/hash/fnv1a.ts ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst OFFSET_BASIS_32 = 2166136261;\nexports.fnv1a = function (s) {\n    let hash = OFFSET_BASIS_32;\n    for (let i = 0; i < s.length; i++) {\n        hash ^= s.charCodeAt(i);\n        // 32-bit FNV prime: 2**24 + 2**8 + 0x93 = 16777619\n        // Using bitshift for accuracy and performance. Numbers in JS suck.\n        hash += (hash << 1) + (hash << 4) + (hash << 7) + (hash << 8) + (hash << 24);\n    }\n    return hash | 0;\n};\n\n\n//# sourceURL=webpack:///./src/ts/util/hash/fnv1a.ts?");

/***/ }),

/***/ "./src/ts/util/iterables.ts":
/*!**********************************!*\
  !*** ./src/ts/util/iterables.ts ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst isType_1 = __webpack_require__(/*! ./types/isType */ \"./src/ts/util/types/isType.ts\");\nvar iterables;\n(function (iterables) {\n    iterables.ofGenerator = function (generator) {\n        return {\n            [Symbol.iterator]: generator,\n        };\n    };\n    iterables.ofIterator = function (iterator) {\n        return iterables.ofGenerator(() => iterator);\n    };\n    iterables.map = function (iterable, map) {\n        if (isType_1.isArray(iterable)) {\n            return iterable.map(map);\n        }\n        return iterables.ofGenerator(function* () {\n            let i = 0;\n            for (const e of iterable) {\n                yield map(e, i++);\n            }\n        });\n    };\n})(iterables = exports.iterables || (exports.iterables = {}));\n\n\n//# sourceURL=webpack:///./src/ts/util/iterables.ts?");

/***/ }),

/***/ "./src/ts/util/objectFields.ts":
/*!*************************************!*\
  !*** ./src/ts/util/objectFields.ts ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst isType_1 = __webpack_require__(/*! ./types/isType */ \"./src/ts/util/types/isType.ts\");\nvar objectFields;\n(function (objectFields) {\n    objectFields.map = function (t, mapper) {\n        return t.mapFields(mapper);\n    };\n    objectFields.callEach = function (functions) {\n        return objectFields.map(functions, f => f());\n    };\n    objectFields.callEachArgs = function (functions, args) {\n        return objectFields.map(functions, f => f(args));\n    };\n    objectFields.awaitAll = function (promises) {\n        if (!Object.values(promises).some(isType_1.isPromise)) {\n            return promises;\n        }\n        return (async () => (await Object.entries(promises)\n            .asyncMap(async ([key, promise]) => [key, await promise])).toObject())();\n    };\n    objectFields.awaitGetters = function (asyncGetters) {\n        return objectFields.awaitAll(objectFields.callEach(asyncGetters));\n    };\n    objectFields.awaitFunctions = function (asyncFunctions, args) {\n        return objectFields.awaitAll(objectFields.callEachArgs(asyncFunctions, args));\n    };\n})(objectFields = exports.objectFields || (exports.objectFields = {}));\n\n\n//# sourceURL=webpack:///./src/ts/util/objectFields.ts?");

/***/ }),

/***/ "./src/ts/util/production.ts":
/*!***********************************!*\
  !*** ./src/ts/util/production.ts ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(global) {\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst process = (global || window).process;\nconst nodeEnv = process && process.env && process.env.NODE_ENV;\nexports.production = !nodeEnv ? false : nodeEnv.toLowerCase() === \"production\";\nexports.development = !exports.production;\nexports.inProduction = function (func) {\n    if (exports.production) {\n        func();\n    }\n};\nexports.inDevelopment = function (func) {\n    if (exports.development) {\n        func();\n    }\n};\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../node_modules/webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack:///./src/ts/util/production.ts?");

/***/ }),

/***/ "./src/ts/util/react.tsx":
/*!*******************************!*\
  !*** ./src/ts/util/react.tsx ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst React = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\nconst react_1 = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\nexports.renderNodes = function (nodes) {\n    return nodes.map((node, i) => React.createElement(react_1.Fragment, { key: i }, node));\n};\nexports.renderNodesObj = function (nodes) {\n    return exports.renderNodes(Object.values(nodes));\n};\n\n\n//# sourceURL=webpack:///./src/ts/util/react.tsx?");

/***/ }),

/***/ "./src/ts/util/regex.ts":
/*!******************************!*\
  !*** ./src/ts/util/regex.ts ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar regex;\n(function (regex_1) {\n    regex_1.toSource = function (regExp) {\n        const { source, flags } = regExp;\n        return `/${source}/${flags}`;\n    };\n    regex_1.join = function (...regexes) {\n        const source = regexes.map(e => e.source).join(\"\");\n        const flagChars = regexes.map(e => e.flags).join(\"\").split(\"\");\n        const flags = flagChars && [...new Set(flagChars)].join(\"\");\n        return new RegExp(source, flags);\n    };\n    regex_1.matchAll = function (regex, s) {\n        if (!regex.global) {\n            throw new Error(\"trying to matchAll with non global regex\");\n        }\n        const matches = [];\n        let match;\n        while (match = regex.exec(s)) {\n            matches.push(match);\n        }\n        return matches;\n    };\n})(regex = exports.regex || (exports.regex = {}));\n\n\n//# sourceURL=webpack:///./src/ts/util/regex.ts?");

/***/ }),

/***/ "./src/ts/util/types/Truthy.ts":
/*!*************************************!*\
  !*** ./src/ts/util/types/Truthy.ts ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.truthy = function (value) {\n    return !!value;\n};\n\n\n//# sourceURL=webpack:///./src/ts/util/types/Truthy.ts?");

/***/ }),

/***/ "./src/ts/util/types/isType.ts":
/*!*************************************!*\
  !*** ./src/ts/util/types/isType.ts ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst utils_1 = __webpack_require__(/*! ../utils */ \"./src/ts/util/utils.ts\");\nexports.isNativeType = function (type) {\n    const typeName = `[object ${utils_1.capitalize(type)}]`;\n    const toString = Object.prototype.toString;\n    return (o) => toString.call(o) === typeName;\n};\n// can use isNativeType for all, but some can be optimized\nexports.isNull = (o) => o === null;\nexports.isUndefined = (o) => o === undefined;\nexports.isBoolean = (o) => o === true || o === false;\nexports.isNumber = exports.isNativeType(\"number\");\nexports.isString = exports.isNativeType(\"string\");\nexports.isFunction = exports.isNativeType(\"Function\"); // TODO can this be optimized?\nexports.isArray = Array.isArray;\nexports.isReadonlyArray = Array.isArray;\nexports.isRegExp = exports.isNativeType(\"RegExp\");\nexports.isDate = exports.isNativeType(\"Date\");\nexports.isObject = exports.isNativeType(\"object\");\nexports.isByConstructor = function (constructor) {\n    return (o) => o.constructor === constructor;\n};\nexports.isDataView = exports.isByConstructor(DataView);\nexports.isArrayBuffer = exports.isByConstructor(ArrayBuffer);\nexports.isPromise = exports.isByConstructor(Promise);\n\n\n//# sourceURL=webpack:///./src/ts/util/types/isType.ts?");

/***/ }),

/***/ "./src/ts/util/types/typeAliases.ts":
/*!******************************************!*\
  !*** ./src/ts/util/types/typeAliases.ts ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.NativeMap = Map;\nexports.NativeSet = Set;\n\n\n//# sourceURL=webpack:///./src/ts/util/types/typeAliases.ts?");

/***/ }),

/***/ "./src/ts/util/utils.ts":
/*!******************************!*\
  !*** ./src/ts/util/utils.ts ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.capitalize = function (word) {\n    return word.length === 0\n        ? \"\"\n        : word[0].toUpperCase() + word.slice(1);\n};\nexports.joinWords = function (words) {\n    const _words = [...words];\n    switch (_words.length) {\n        case 0:\n            return \"\";\n        case 1:\n            return _words[0];\n        case 2:\n            return _words[0] + \" and \" + _words[1];\n        default:\n            const lastWord = _words.pop();\n            return _words.join(\", \") + \", and \" + lastWord;\n    }\n};\nexports.camelCase = (() => {\n    // from react-faux-dom/lib/utils/camelCase.js\n    const hyphenPattern = /-+([a-z])/gi;\n    return function (s) {\n        hyphenPattern.lastIndex = 0;\n        return s.replace(hyphenPattern, (match, c, offset) => {\n            return offset === 0 ? c : c.toUpperCase();\n        });\n    };\n})();\nexports.separateClassName = function (className) {\n    return className.replace(/([A-Z])/g, \" $1\").trim();\n};\nexports.separateFunctionName = function (functionName) {\n    const [first, ...rest] = exports.separateClassName(functionName).split(\" \");\n    return [exports.capitalize(first), ...rest].join(\" \");\n};\nexports.joinNodes = function (nodes, node) {\n    if (nodes.length < 2) {\n        return nodes;\n    }\n    const joinedNodes = [];\n    for (let i = 0, j = 0; i < nodes.length; i++) {\n        joinedNodes.push(nodes[i]);\n        joinedNodes.push(node && node._clone());\n    }\n    joinedNodes.pop();\n    return joinedNodes;\n};\nexports.singletonAsArray = function (singletonOrArray) {\n    return Array.isArray(singletonOrArray) ? singletonOrArray : [singletonOrArray];\n};\nexports.filterInput = function (input, charFilter) {\n    input.value = input.value.split(\"\").filter(charFilter).join(\"\");\n};\n/**\n * Check if a single character string is a allowDigits.\n *\n * @param {string} char a single character string\n * @returns {boolean} if the character is a allowDigits 0-9\n */\nexports.isDigit = function (char) {\n    return !Number.isNaN(parseInt(char));\n};\nexports.onlyDigitsInput = function (input) {\n    exports.filterInput(input, exports.isDigit);\n};\nexports.sleep = function (seconds) {\n    return new Promise(resolve => setTimeout(resolve, seconds * 1000));\n};\nconst regExpLiteralPattern = /\\/([^\\/]+)\\/([gimuy]*)/;\nexports.isRegExpLiteral = function (regex) {\n    return regExpLiteralPattern.test(regex);\n};\nexports.parseRegExpLiteral = function (regex) {\n    const match = regExpLiteralPattern.exec(regex);\n    if (match) {\n        const [, pattern, flags] = match;\n        return new RegExp(pattern, flags);\n    }\n    else {\n        return undefined;\n    }\n};\nexports.escapeRegExp = function (literal, flags) {\n    return new RegExp(literal.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, \"\\\\$&\"), flags);\n};\nclass NotImplementedError extends Error {\n}\nexports.NotImplementedError = NotImplementedError;\nexports.lowerBound = function (min, n) {\n    return Math.max(min, n);\n};\nexports.upperBound = function (max, n) {\n    return Math.min(max, n);\n};\nexports.bound = function (min, max, n) {\n    return exports.lowerBound(min, exports.upperBound(max, n));\n};\nexports.boundSurrounding = function (min, max, center, halfSize) {\n    return [exports.lowerBound(min, center - halfSize), exports.upperBound(max, center + halfSize)];\n};\nexports.snippet = function (s, center, halfSize) {\n    const [start, end] = exports.boundSurrounding(0, s.length, center, halfSize);\n    return s.slice(start, end);\n};\nexports.boolAsInt = function (bool) {\n    return bool ? 1 : 0;\n};\nexports.moduloIndexer = function (a) {\n    return i => a[i % a.length];\n};\n\n\n//# sourceURL=webpack:///./src/ts/util/utils.ts?");

/***/ })

}]);